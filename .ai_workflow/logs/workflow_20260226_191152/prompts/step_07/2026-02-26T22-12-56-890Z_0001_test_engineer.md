# Prompt Log

**Timestamp:** 2026-02-26T22:12:56.890Z
**Persona:** test_engineer
**Model:** gpt-4.1

## Prompt

```
You are a senior test engineer. Generate a complete, runnable test file for the source file below.

**Source file**: `src/core/GeoPosition.ts`
**Language / framework**: typescript

**Requirements**:
- Output ONLY the test file content inside a single fenced code block (```ts ... ```)
- Cover: happy paths, edge cases, and error scenarios
- Use the standard test framework for typescript (e.g. Jest for JS/TS, pytest for Python)
- Use descriptive test names
- Do NOT include explanations outside the code block

```ts
/**
 * Geographic position data wrapper with convenience methods.
 * 
 * Provides an immutable wrapper around browser Geolocation API position data,
 * adding convenience methods for distance calculations and accuracy assessment.
 * 
 * @module core/GeoPosition
 * @since 0.6.0-alpha
 * @author Marcelo Pereira Barbosa
 */

import { calculateDistance } from '../utils/distance.js';

/**
 * Coordinate properties extracted from a GeolocationCoordinates object.
 * All fields are optional to accommodate missing or partial position data.
 */
export interface GeoCoords {
	latitude?: number;
	longitude?: number;
	accuracy?: number;
	altitude?: number | null;
	altitudeAccuracy?: number | null;
	heading?: number | null;
	speed?: number | null;
}

/**
 * Input shape accepted by the GeoPosition constructor.
 * Compatible with the browser GeolocationPosition API and plain test objects.
 */
export interface GeoPositionInput {
	timestamp?: number;
	coords?: GeoCoords;
}

/** GPS accuracy quality classification. */
export type AccuracyQuality = 'excellent' | 'good' | 'medium' | 'bad' | 'very bad';

/** Normalised internal position shape stored on the instance. */
interface NormalisedPosition {
	readonly timestamp: number | undefined;
	readonly coords: Readonly<GeoCoords>;
}

/**
 * Represents a geographic position with enhanced methods.
 * 
 * @class
 * @immutable All instances and their nested objects are frozen after creation
 */
class GeoPosition {
	readonly geolocationPosition: Readonly<NormalisedPosition> | null;
	readonly coords: Readonly<GeoCoords> | null;
	readonly latitude: number | undefined;
	readonly longitude: number | undefined;
	readonly accuracy: number | undefined;
	readonly accuracyQuality: AccuracyQuality;
	readonly altitude: number | null | undefined;
	readonly altitudeAccuracy: number | null | undefined;
	readonly heading: number | null | undefined;
	readonly speed: number | null | undefined;
	readonly timestamp: number | undefined;

	constructor(position: GeoPositionInput) {
		const coords = GeoPosition.parseCoords(position?.coords);

		this.geolocationPosition = position
			? Object.freeze({ timestamp: position.timestamp, coords })
			: null;
		this.coords = Object.keys(coords).length > 0 ? coords : null;
		this.latitude = coords.latitude;
		this.longitude = coords.longitude;
		this.accuracy = coords.accuracy;
		this.accuracyQuality = GeoPosition.getAccuracyQuality(coords.accuracy ?? Infinity);
		this.altitude = coords.altitude;
		this.altitudeAccuracy = coords.altitudeAccuracy;
		this.heading = coords.heading;
		this.speed = coords.speed;
		this.timestamp = position?.timestamp;
		Object.freeze(this);
	}

	/**
	 * Extracts and deeply freezes coordinate properties from a raw coords object.
	 * 
	 * GeolocationCoordinates exposes properties via non-enumerable getters, so the
	 * spread operator produces an empty object. Explicit extraction is required.
	 * 
	 * @private
	 * @param {GeoCoords} [rawCoords] - Raw coords from a GeolocationPosition or plain object
	 * @returns {Readonly<GeoCoords>} Frozen defensive copy of the coordinate properties
	 */
	private static parseCoords(rawCoords?: GeoCoords): Readonly<GeoCoords> {
		if (!rawCoords) return Object.freeze({});
		return Object.freeze({
			latitude: rawCoords.latitude,
			longitude: rawCoords.longitude,
			accuracy: rawCoords.accuracy,
			altitude: rawCoords.altitude,
			altitudeAccuracy: rawCoords.altitudeAccuracy,
			heading: rawCoords.heading,
			speed: rawCoords.speed,
		});
	}

	/**
	 * Factory method — creates a GeoPosition from a GeoPositionInput.
	 * 
	 * @param {GeoPositionInput} position - Raw position input
	 * @returns {GeoPosition} New immutable GeoPosition instance
	 * 
	 * @example
	 * const pos = GeoPosition.from(browserPosition);
	 * 
	 * @since 0.6.0-alpha
	 */
	static from(position: GeoPositionInput): GeoPosition {
		return new GeoPosition(position);
	}

	/**
	 * Classifies GPS accuracy into quality levels based on accuracy value in meters.
	 * 
	 * Provides a standardized way to assess the quality of GPS position data
	 * based on the accuracy reported by the device. Lower values indicate better accuracy.
	 * 
	 * Quality Levels:
	 * - excellent: ≤ 10 meters (high precision, suitable for all applications)
	 * - good: 11-30 meters (good precision, suitable for most applications)  
	 * - medium: 31-100 meters (moderate precision, may be acceptable for some uses)
	 * - bad: 101-200 meters (poor precision, generally not recommended)
	 * - very bad: > 200 meters (very poor precision, should be rejected)
	 * 
	 * @static
	 * @param {number} accuracy - GPS accuracy value in meters; pass `Infinity` for unknown/missing accuracy
	 * @returns {AccuracyQuality} Quality classification
	 * 
	 * @example
	 * GeoPosition.getAccuracyQuality(5);        // 'excellent'
	 * GeoPosition.getAccuracyQuality(25);       // 'good'
	 * GeoPosition.getAccuracyQuality(75);       // 'medium'
	 * GeoPosition.getAccuracyQuality(150);      // 'bad'
	 * GeoPosition.getAccuracyQuality(500);      // 'very bad'
	 * GeoPosition.getAccuracyQuality(Infinity); // 'very bad'
	 * 
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/GeolocationCoordinates/accuracy} GeolocationCoordinates.accuracy
	 * @since 0.6.0-alpha
	 */
	static getAccuracyQuality(accuracy: number): AccuracyQuality {
		if (accuracy <= 10) {
			return "excellent";
		} else if (accuracy <= 30) {
			return "good";
		} else if (accuracy <= 100) {
			return "medium";
		} else if (accuracy <= 200) {
			return "bad";
		} else {
			return "very bad";
		}
	}

	/**
	 * Calculates the accuracy quality for the current position.
	 * 
	 * @returns {AccuracyQuality} Quality classification for current position accuracy
	 * 
	 * @example
	 * const pos = new GeoPosition(position);
	 * pos.calculateAccuracyQuality(); // 'good'
	 * 
	 * @since 0.6.0-alpha
	 * @deprecated Use the `accuracyQuality` property instead.
	 */
	calculateAccuracyQuality(): AccuracyQuality {
		return GeoPosition.getAccuracyQuality(this.accuracy ?? Infinity);
	}

	/**
	 * Calculates the distance between this position and another position.
	 * 
	 * Uses the Haversine formula to compute the great-circle distance between
	 * two geographic points. Useful for determining how far the device has
	 * moved or measuring distances to other locations.
	 * 
	 * @param {Object} otherPosition - Other position to calculate distance to
	 * @param {number} otherPosition.latitude - Latitude of other position in decimal degrees
	 * @param {number} otherPosition.longitude - Longitude of other position in decimal degrees
	 * @returns {number} Distance in meters, or `NaN` if this position has no coordinates
	 * 
	 * @example
	 * const pos = new GeoPosition(currentPosition);
	 * const restaurant = { latitude: -23.5489, longitude: -46.6388 };
	 * const distance = pos.distanceTo(restaurant);
	 * console.log(`Restaurant is ${Math.round(distance)} meters away`);
	 * 
	 * @see {@link calculateDistance} - The underlying distance calculation function
	 * @since 0.6.0-alpha
	 */
	distanceTo(otherPosition: { latitude: number; longitude: number }): number {
		if (this.latitude === undefined || this.longitude === undefined) {
			return NaN;
		}
		return calculateDistance(
			this.latitude,
			this.longitude,
			otherPosition.latitude,
			otherPosition.longitude,
		);
	}

	/**
	 * Returns a string representation of the GeoPosition instance.
	 * 
	 * Provides a formatted summary of key position properties for debugging
	 * and logging purposes.
	 * 
	 * @returns {string} Formatted string with position details
	 * 
	 * @example
	 * const position = new GeoPosition(geolocationPosition);
	 * console.log(position.toString());
	 * // Output: "GeoPosition: -23.5505, -46.6333, good, 760, 0, 0, 1634567890123"
	 * 
	 * @since 0.6.0-alpha
	 */
	toString(): string {
		if (!this.latitude || !this.longitude) {
			return `${this.constructor.name}: No position data`;
		}
		return `${this.constructor.name}: ${this.latitude}, ${this.longitude}, ${this.accuracyQuality}, ${this.altitude}, ${this.speed}, ${this.heading}, ${this.timestamp}`;
	}
}

export default GeoPosition;

```

Now generate the test file:
```

## Response

```
```ts
// src/core/GeoPosition.test.ts

import GeoPosition, { GeoCoords, GeoPositionInput, AccuracyQuality } from './GeoPosition';
import { calculateDistance } from '../utils/distance.js';

jest.mock('../utils/distance.js', () => ({
	calculateDistance: jest.fn(),
}));

describe('GeoPosition', () => {
	const mockDistance = 1234.56;
	beforeEach(() => {
		(calculateDistance as jest.Mock).mockReturnValue(mockDistance);
	});

	describe('constructor', () => {
		it('should create a GeoPosition with full data', () => {
			const input: GeoPositionInput = {
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			};
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBe(-23.5505);
			expect(pos.longitude).toBe(-46.6333);
			expect(pos.accuracy).toBe(15);
			expect(pos.altitude).toBe(760);
			expect(pos.altitudeAccuracy).toBe(5);
			expect(pos.heading).toBe(0);
			expect(pos.speed).toBe(0);
			expect(pos.timestamp).toBe(1634567890123);
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			});
			expect(Object.isFrozen(pos)).toBe(true);
			expect(Object.isFrozen(pos.geolocationPosition!)).toBe(true);
			expect(Object.isFrozen(pos.coords!)).toBe(true);
		});

		it('should handle missing coords gracefully', () => {
			const input: GeoPositionInput = { timestamp: 1234567890 };
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1234567890,
				coords: {},
			});
		});

		it('should handle null/undefined input', () => {
			const pos = new GeoPosition({} as GeoPositionInput);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: undefined,
				coords: {},
			});
		});

		it('should handle partial coords', () => {
			const input: GeoPositionInput = {
				coords: { latitude: 10.5 },
			};
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBe(10.5);
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toEqual({ latitude: 10.5 });
		});
	});

	describe('parseCoords', () => {
		it('should freeze returned object', () => {
			const coords: GeoCoords = { latitude: 1, longitude: 2 };
			const pos = new GeoPosition({ coords });
			expect(Object.isFrozen(pos.coords!)).toBe(true);
		});
		it('should return empty frozen object for undefined', () => {
			const pos = new GeoPosition({});
			expect(pos.coords).toBeNull();
			expect(Object.isFrozen(pos.geolocationPosition!.coords)).toBe(true);
		});
	});

	describe('from', () => {
		it('should create a GeoPosition instance', () => {
			const input: GeoPositionInput = {
				timestamp: 1000,
				coords: { latitude: 1, longitude: 2, accuracy: 5 },
			};
			const pos = GeoPosition.from(input);
			expect(pos).toBeInstanceOf(GeoPosition);
			expect(pos.latitude).toBe(1);
			expect(pos.longitude).toBe(2);
			expect(pos.accuracy).toBe(5);
		});
	});

	describe('getAccuracyQuality', () => {
		const cases: [number, AccuracyQuality][] = [
			[5, 'excellent'],
			[10, 'excellent'],
			[11, 'good'],
			[30, 'good'],
			[31, 'medium'],
			[100, 'medium'],
			[101, 'bad'],
			[200, 'bad'],
			[201, 'very bad'],
			[500, 'very bad'],
			[Infinity, 'very bad'],
			[-1, 'excellent'],
		];
		it.each(cases)(
			'should classify accuracy %p as %p',
			(accuracy, expected) => {
				expect(GeoPosition.getAccuracyQuality(accuracy)).toBe(expected);
			},
		);
	});

	describe('calculateAccuracyQuality', () => {
		it('should return correct quality for current accuracy', () => {
			const pos = new GeoPosition({
				coords: { latitude: 1, longitude: 2, accuracy: 25 },
			});
			expect(pos.calculateAccuracyQuality()).toBe('good');
		});
		it('should return "very bad" for missing accuracy', () => {
			const pos = new GeoPosition({ coords: { latitude: 1, longitude: 2 } });
			expect(pos.calculateAccuracyQuality()).toBe('very bad');
		});
	});

	describe('distanceTo', () => {
		it('should call calculateDistance with correct args', () => {
			const pos = new GeoPosition({
				coords: { latitude: 10, longitude: 20 },
			});
			const other = { latitude: 30, longitude: 40 };
			const result = pos.distanceTo(other);
			expect(calculateDistance).toHaveBeenCalledWith(10, 20, 30, 40);
			expect(result).toBe(mockDistance);
		});
		it('should return NaN if latitude is undefined', () => {
			const pos = new GeoPosition({ coords: { longitude: 20 } });
			const other = { latitude: 30, longitude: 40 };
			expect(pos.distanceTo(other)).toBeNaN();
		});
		it('should return NaN if longitude is undefined', () => {
			const pos = new GeoPosition({ coords: { latitude: 10 } });
			const other = { latitude: 30, longitude: 40 };
			expect(pos.distanceTo(other)).toBeNaN();
		});
	});

	describe('toString', () => {
		it('should return formatted string for valid position', () => {
			const pos = new GeoPosition({
				timestamp: 1234567890,
				coords: {
					latitude: 1.1,
					longitude: 2.2,
					accuracy: 15,
					altitude: 100,
					speed: 5,
					heading: 90,
				},
			});
			expect(pos.toString()).toBe(
				`GeoPosition: 1.1, 2.2, good, 100, 5, 90, 1234567890`,
			);
		});
		it('should return "No position data" if latitude/longitude missing', () => {
			const pos = new GeoPosition({});
			expect(pos.toString()).toBe('GeoPosition: No position data');
		});
		it('should handle falsy latitude/longitude (0)', () => {
			const pos = new GeoPosition({
				coords: { latitude: 0, longitude: 0 },
			});
			expect(pos.toString()).toBe('GeoPosition: No position data');
		});
	});

	describe('immutability', () => {
		it('should not allow mutation of instance properties', () => {
			const pos = new GeoPosition({
				coords: { latitude: 1, longitude: 2, accuracy: 5 },
			});
			expect(() => {
				// @ts-expect-error
				pos.latitude = 99;
			}).toThrow();
			expect(() => {
				// @ts-expect-error
				pos.coords.latitude = 99;
			}).toThrow();
		});
	});
});
```
```