# Prompt Log

**Timestamp:** 2026-03-01T02:25:35.692Z
**Persona:** test_engineer
**Model:** gpt-4.1

## Prompt

```
**Role**: You are a hands-on test engineer and code quality specialist focused on reviewing existing test implementations, writing new test cases, assessing test code quality, and ensuring testing best practices are followed. You work with actual test code, not just strategy.

**Task**: Review existing test implementations and provide tactical recommendations for improving test code quality.

**Context:**
- Project: paraty_geocore.js (N/A)
- Primary Language: typescript
- Test Config: jest in npm test
- Commands: test=`npm test`, coverage=`npm run coverage`
- Total Test Files: 9
- Tests in __tests__/: 0
- Co-located Tests: 9

**Existing Test Files:**
test/index.test.ts, test/utils/async.test.ts, test/integration/browser-geolocation.test.ts, test/core/GeoPosition.edge-cases.test.ts, test/core/GeoPosition.test.ts, test/core/GeocodingState.test.ts, test/core/errors.test.ts, test/benchmarks/performance.benchmark.ts, test/helpers/fixtures.ts

**Test File Contents:**
### test/index.test.ts
```typescript
/**
 * Smoke / contract tests for the public re-export surface of src/index.ts.
 *
 * These tests confirm that every symbol advertised by the package entry-point
 * is exported, has the correct shape, and behaves as documented.
 */
import {
  GeoPosition,
  GeoPositionError,
  calculateDistance,
  EARTH_RADIUS_METERS,
  delay,
} from '../src/index';
import type { GeoCoords, GeoPositionInput, AccuracyQuality } from '../src/index';
import { TEST_TIMESTAMP } from './helpers/fixtures';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Minimal valid GeoPositionInput using the coords-wrapper shape. */
function makeInput(lat: number, lon: number, accuracy = 10): GeoPositionInput {
  return { coords: { latitude: lat, longitude: lon, accuracy }, timestamp: TEST_TIMESTAMP };
}

// ---------------------------------------------------------------------------
// GeoPosition
// ---------------------------------------------------------------------------

describe('GeoPosition (exported from index)', () => {
  it('is the default export and is a constructor', () => {
    expect(typeof GeoPosition).toBe('function');
  });

  it('creates an instance from a valid GeoPositionInput', () => {
    const pos = new GeoPosition(makeInput(40.7128, -74.006, 5));
    expect(pos.latitude).toBe(40.7128);
    expect(pos.longitude).toBe(-74.006);
    expect(pos.accuracy).toBe(5);
    expect(pos.timestamp).toBe(TEST_TIMESTAMP);
  });

  it('instance is frozen (immutable)', () => {
    const pos = new GeoPosition(makeInput(0, 0));
    expect(Object.isFrozen(pos)).toBe(true);
  });

  it('throws GeoPositionError when given a primitive', () => {
    expect(() => new GeoPosition(42 as any)).toThrow(GeoPositionError);
    expect(() => new GeoPosition('string' as any)).toThrow(GeoPositionError);
    expect(() => new GeoPosition(true as any)).toThrow(GeoPositionError);
  });

  it.each<[number, number]>([
    [-90, -180],
    [90, 180],
    [0, 0],
  ])('does NOT throw for extreme-but-valid coordinates: %p, %p', (lat, lon) => {
    expect(() => new GeoPosition(makeInput(lat, lon))).not.toThrow();
  });

  it('returns no-position string from toString() when coords are absent', () => {
    const pos = new GeoPosition({} as GeoPositionInput);
    expect(pos.toString()).toMatch(/No position data/);
  });

  describe('GeoPosition.from() factory', () => {
    it('returns a GeoPosition equal to new GeoPosition()', () => {
      const input = makeInput(-23.5505, -46.6333, 12);
      const a = new GeoPosition(input);
      const b = GeoPosition.from(input);
      expect(b.latitude).toBe(a.latitude);
      expect(b.longitude).toBe(a.longitude);
    });
  });

  describe('GeoPosit
... (truncated)
```

### test/utils/async.test.ts
```typescript
// test/utils/async.test.ts
import { delay } from '../../src/utils/async';

describe('utils/async delay', () => {
  it('should resolve after the specified milliseconds', async () => {
    const start = Date.now();
    await delay(50);
    expect(Date.now() - start).toBeGreaterThanOrEqual(45); // allow ±5ms for timer imprecision
  });

  it('should resolve immediately for 0 ms', async () => {
    const start = Date.now();
    await delay(0);
    expect(Date.now() - start).toBeLessThan(20); // event-loop tick; allow up to 20ms
  });

  it('should resolve immediately for negative ms (clamped to 0)', async () => {
    // Negative values are clamped to 0; resolves on the next event-loop tick.
    const start = Date.now();
    await delay(-10);
    expect(Date.now() - start).toBeLessThan(20);
  });

  it('should work with large ms values', async () => {
    jest.useFakeTimers();
    try {
      const promise = delay(1000);
      jest.advanceTimersByTime(1000);
      await expect(promise).resolves.toBeUndefined();
    } finally {
      jest.useRealTimers();
    }
  });

  it('should be a Promise', () => {
    const result = delay(10);
    expect(result).toBeInstanceOf(Promise);
  });
});

```

### test/integration/browser-geolocation.test.ts
```typescript
/**
 * Integration tests — browser Geolocation API simulation
 *
 * These tests verify the full pipeline using GeolocationPosition objects
 * that simulate the browser implementation: coords are exposed via
 * non-enumerable getters (spread / Object.assign produce an empty object),
 * which is the exact behaviour that GeoPosition.parseCoords must handle.
 */

import GeoPosition from '../../src/core/GeoPosition';
import { calculateDistance } from '../../src/utils/distance';
import { TEST_TIMESTAMP } from '../helpers/fixtures';

// ---------------------------------------------------------------------------
// Browser GeolocationPosition factory
// ---------------------------------------------------------------------------

interface FakeCoords {
  latitude: number;
  longitude: number;
  accuracy: number;
  altitude?: number | null;
  altitudeAccuracy?: number | null;
  heading?: number | null;
  speed?: number | null;
}

/**
 * Creates a GeolocationPosition-like object whose coords properties are
 * exposed as non-enumerable getters — identical to Chrome / Firefox behaviour.
 */
function makeBrowserPosition(coords: FakeCoords, timestamp = Date.now()): object {
  const coordsObj = Object.create(null);
  for (const [key, value] of Object.entries(coords) as [keyof FakeCoords, unknown][]) {
    Object.defineProperty(coordsObj, key, {
      get: () => value ?? null,
      enumerable: false,  // non-enumerable: spread/assign yields {}
      configurable: false,
    });
  }

  const positionObj = Object.create(null);
  Object.defineProperty(positionObj, 'coords', { get: () => coordsObj, enumerable: true });
  Object.defineProperty(positionObj, 'timestamp', { get: () => timestamp, enumerable: true });
  return positionObj;
}

// ---------------------------------------------------------------------------
// Shared fixture
// ---------------------------------------------------------------------------

const SAO_PAULO = { latitude: -23.5505, longitude: -46.6333, accuracy: 12 };
const RIO_DE_JANEIRO = { latitude: -22.9068, longitude: -43.1729, accuracy: 18 };
const EXPECTED_SP_RIO_METERS = 360_748; // Haversine result for the given coordinates, ±1%

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

describe('Integration: browser GeolocationPosition → GeoPosition', () => {
  describe('non-enumerable coords extraction', () => {
    it('reads latitude and longitude from non-enumerable getters', () => {
      const raw = makeBrowserPosition(SAO_PAULO, TEST_TIMESTAMP);
      const pos = new GeoPosition(raw as any);

      expect(pos.latitude).toBe(SAO_PAULO.latitude);
      expect(pos.longitude).toBe(SAO_PAULO.longitude);
      expect(pos.accuracy).toB
... (truncated)
```

### test/core/GeoPosition.edge-cases.test.ts
```typescript
/**
 * Edge-case tests for GeoPosition.
 *
 * Covers unusual, boundary, and malformed inputs not exercised by the main unit tests.
 */

import GeoPosition from '../../src/core/GeoPosition';
import { GeoPositionError } from '../../src/core/errors';

describe('GeoPosition — edge cases', () => {

  // -------------------------------------------------------------------------
  // Input validation / error handling
  // -------------------------------------------------------------------------

  describe('constructor — invalid primitive input', () => {
    it.each([42, 'string', true, Symbol('s')])(
      'throws GeoPositionError for primitive: %p',
      (primitive) => {
        expect(() => new GeoPosition(primitive as any)).toThrow(GeoPositionError);
        expect(() => new GeoPosition(primitive as any)).toThrow(/must be an object/);
      },
    );

    it('thrown error is also an instance of Error', () => {
      expect(() => new GeoPosition(99 as any)).toThrow(Error);
    });

    it('thrown error has name "GeoPositionError"', () => {
      expect(() => new GeoPosition('bad' as any)).toThrow(
        expect.objectContaining({ name: 'GeoPositionError' }),
      );
    });

    it('accepts null-ish objects gracefully (no throw)', () => {
      expect(() => new GeoPosition({})).not.toThrow();
      expect(() => new GeoPosition({ coords: undefined })).not.toThrow();
    });
  });

  // -------------------------------------------------------------------------
  // Extreme coordinate values
  // -------------------------------------------------------------------------

  describe('extreme coordinate values', () => {
    it('handles latitude = +90 (North Pole)', () => {
      const pos = new GeoPosition({ coords: { latitude: 90, longitude: 0, accuracy: 5 } });
      expect(pos.latitude).toBe(90);
      expect(pos.accuracyQuality).toBe('excellent');
    });

    it('handles latitude = -90 (South Pole)', () => {
      const pos = new GeoPosition({ coords: { latitude: -90, longitude: 0, accuracy: 5 } });
      expect(pos.latitude).toBe(-90);
    });

    it('handles longitude = +180 (antimeridian east)', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: 180, accuracy: 10 } });
      expect(pos.longitude).toBe(180);
    });

    it('handles longitude = -180 (antimeridian west)', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: -180, accuracy: 10 } });
      expect(pos.longitude).toBe(-180);
    });

    it('handles very large positive accuracy', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: 0, accuracy: 1_000_000 } });
      expect(pos.accuracyQuality).toBe('very bad');
    });

    it('handles accuracy = 0', () => {
      const pos = new GeoPosition({ coords: { latitude: 
... (truncated)
```

### test/core/GeoPosition.test.ts
```typescript
// src/core/GeoPosition.test.ts

import GeoPosition, { GeoCoords, GeoPositionInput, AccuracyQuality } from '../../src/core/GeoPosition';
import { calculateDistance } from '../../src/utils/distance';

jest.mock('../../src/utils/distance', () => ({
	calculateDistance: jest.fn(),
}));

describe('GeoPosition', () => {
	const mockDistance = 1234.56;
	beforeEach(() => {
		(calculateDistance as jest.Mock).mockReturnValue(mockDistance);
	});

	describe('constructor', () => {
		it('should create a GeoPosition with full data', () => {
			const input: GeoPositionInput = {
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			};
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBe(-23.5505);
			expect(pos.longitude).toBe(-46.6333);
			expect(pos.accuracy).toBe(15);
			expect(pos.altitude).toBe(760);
			expect(pos.altitudeAccuracy).toBe(5);
			expect(pos.heading).toBe(0);
			expect(pos.speed).toBe(0);
			expect(pos.timestamp).toBe(1634567890123);
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			});
			expect(Object.isFrozen(pos)).toBe(true);
			expect(Object.isFrozen(pos.geolocationPosition!)).toBe(true);
			expect(Object.isFrozen(pos.coords!)).toBe(true);
		});

		it('should handle missing coords gracefully', () => {
			const input: GeoPositionInput = { timestamp: 1234567890 };
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1234567890,
				coords: {},
			});
		});

		it('should handle null/undefined input', () => {
			const pos = new GeoPosition({} as GeoPositionInput);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: undefined,
				coords: {},
			});
		});

		it('should handle partial coords', () => {
			const input: GeoPositionInput = {
				coords: { latitude: 10.5 },
			};
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBe(10.5);
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toEqual({ latitude: 10.5 });
		});
	});

	describe('parseCoords', () => {
		it('should freeze returned object', () => {
			const coords: GeoCoords = { latitude: 1, longitude: 2 };
			cons
... (truncated)
```

### test/core/GeocodingState.test.ts
```typescript
// test/core/GeocodingState.test.ts

import GeocodingState from '../../src/core/GeocodingState';
import GeoPosition from '../../src/core/GeoPosition';
import type { GeoPositionInput } from '../../src/core/GeoPosition';

function mockPos(lat: number, lon: number): GeoPositionInput {
return {
coords: {
latitude: lat,
longitude: lon,
accuracy: 15,
altitude: null,
altitudeAccuracy: null,
heading: null,
speed: null,
},
timestamp: Date.now(),
};
}

describe('GeocodingState', () => {
describe('constructor', () => {
it('should create instance with null initial state', () => {
const state = new GeocodingState();
expect(state).toBeInstanceOf(GeocodingState);
expect(state.getCurrentPosition()).toBeNull();
expect(state.getCurrentCoordinates()).toBeNull();
});

it('should initialize with zero observers', () => {
const state = new GeocodingState();
expect(state.getObserverCount()).toBe(0);
});
});

describe('setPosition()', () => {
it('should update position with a valid GeoPosition', () => {
const state = new GeocodingState();
const pos = new GeoPosition(mockPos(-23.5505, -46.6333));
state.setPosition(pos);
expect(state.getCurrentPosition()).toBe(pos);
});

it('should update coordinates when position is set', () => {
const state = new GeocodingState();
state.setPosition(new GeoPosition(mockPos(-23.5505, -46.6333)));
expect(state.getCurrentCoordinates()).toEqual({ latitude: -23.5505, longitude: -46.6333 });
});

it('should accept null to clear position', () => {
const state = new GeocodingState();
state.setPosition(new GeoPosition(mockPos(-23.5505, -46.6333)));
state.setPosition(null);
expect(state.getCurrentPosition()).toBeNull();
expect(state.getCurrentCoordinates()).toBeNull();
});

it('should throw TypeError for non-GeoPosition values', () => {
const state = new GeocodingState();
expect(() => state.setPosition({ latitude: 10, longitude: 20 } as any)).toThrow(TypeError);
expect(() => state.setPosition('invalid' as any)).toThrow(TypeError);
expect(() => state.setPosition(123 as any)).toThrow(TypeError);
});

it('should notify observers when position changes', () => {
const state = new GeocodingState();
const observer = jest.fn();
const pos = new GeoPosition(mockPos(-23.5505, -46.6333));
state.subscribe(observer);
state.setPosition(pos);
expect(observer).toHaveBeenCalledTimes(1);
expect(observer).toHaveBeenCalledWith({
position: pos,
coordinates: { latitude: -23.5505, longitude: -46.6333 },
});
});

it('should not notify observers when set to null', () => {
const state = new GeocodingState();
const observer = jest.fn();
state.subscribe(observer);
state.setPosition(null);
expect(observer).not.toHaveBeenCalled();
});

it('should handle observer errors gracefully', () => {
const state = new GeocodingState();
const errorObserver = jest.fn(() => { throw new Error('boo
... (truncated)
```

### test/core/errors.test.ts
```typescript
// test/core/errors.test.ts
import { GeoPositionError } from '../../src/core/errors';

describe('GeoPositionError', () => {
  it('should be instance of Error', () => {
    const err = new GeoPositionError('Invalid position');
    expect(err).toBeInstanceOf(Error);
    expect(err).toBeInstanceOf(GeoPositionError);
  });

  it('should set the correct name', () => {
    const err = new GeoPositionError('Test error');
    expect(err.name).toBe('GeoPositionError');
  });

  it('should set the correct message', () => {
    const err = new GeoPositionError('GeoPosition: position must be an object');
    expect(err.message).toBe('GeoPosition: position must be an object');
  });

  it('should maintain prototype chain', () => {
    const err = new GeoPositionError('Chain test');
    expect(Object.getPrototypeOf(err)).toBe(GeoPositionError.prototype);
  });

  it('should be catchable as GeoPositionError', () => {
    const err = new GeoPositionError('Catch test');
    expect(err).toBeInstanceOf(GeoPositionError);
    expect(err.message).toBe('Catch test');
  });

  it('should allow custom properties', () => {
    const err = new GeoPositionError('Custom');
    (err as any).code = 123;
    expect((err as any).code).toBe(123);
  });
});

```

### test/benchmarks/performance.benchmark.ts
```typescript
/**
 * Performance benchmarks — paraty_geocore.js
 *
 * Measures throughput and per-operation latency for core library functions.
 * Run with: npm run bench
 *
 * Thresholds are intentionally generous (wall-clock, CI-safe) and serve as
 * regression guards rather than strict performance contracts.
 */

import GeoPosition from '../../src/core/GeoPosition';
import { calculateDistance } from '../../src/utils/distance';
import { TEST_TIMESTAMP } from '../helpers/fixtures';

const ITERATIONS = 100_000;

// Increase Jest timeout for benchmark tests
jest.setTimeout(30_000);

function bench(label: string, fn: () => void, iterations = ITERATIONS): number {
  // Warm-up pass (avoid JIT cold-start skewing results)
  for (let i = 0; i < Math.min(1_000, iterations); i++) fn();

  const start = performance.now();
  for (let i = 0; i < iterations; i++) fn();
  const elapsed = performance.now() - start;
  const perOpUs = (elapsed / iterations) * 1_000;

  console.log(
    `  : ${iterations.toLocaleString()} ops in ${elapsed.toFixed(1)}ms ` +
    `(${perOpUs.toFixed(3)} µs/op)`,
  );
  return elapsed;
}

// ---------------------------------------------------------------------------

describe('Performance Benchmarks', () => {
  describe('utils/distance', () => {
    it(`calculateDistance — ${ITERATIONS.toLocaleString()} iterations complete in < 500ms`, () => {
      const elapsed = bench('calculateDistance', () =>
        calculateDistance(-23.5505, -46.6333, -22.9068, -43.1729),
      );
      expect(elapsed).toBeLessThan(500);
    });

    it('calculateDistance — same-point shortcut stays < 500ms', () => {
      const elapsed = bench('calculateDistance (same point)', () =>
        calculateDistance(-23.5505, -46.6333, -23.5505, -46.6333),
      );
      expect(elapsed).toBeLessThan(500);
    });
  });

  describe('core/GeoPosition', () => {
    const input = {
      timestamp: TEST_TIMESTAMP,
      coords: {
        latitude: -23.5505,
        longitude: -46.6333,
        accuracy: 12,
        altitude: 760,
        altitudeAccuracy: 5,
        heading: null,
        speed: 0,
      },
    };

    it(`GeoPosition construction — ${ITERATIONS.toLocaleString()} iterations complete in < 2000ms`, () => {
      const elapsed = bench('new GeoPosition()', () => new GeoPosition(input));
      expect(elapsed).toBeLessThan(2_000);
    });

    it(`GeoPosition.from() — ${ITERATIONS.toLocaleString()} iterations complete in < 2000ms`, () => {
      const elapsed = bench('GeoPosition.from()', () => GeoPosition.from(input));
      expect(elapsed).toBeLessThan(2_000);
    });

    it(`getAccuracyQuality — ${ITERATIONS.toLocaleString()} iterations complete in < 100ms`, () => {
      const elapsed = bench('getAccuracyQuality', () => GeoPosition.getAccuracyQuality(15));
      e
... (truncated)
```

### test/helpers/fixtures.ts
```typescript
/**
 * Shared test fixtures and constants for paraty_geocore.js test suites.
 *
 * Import these instead of repeating magic values across test files.
 */

/**
 * A stable, well-known Unix timestamp used across unit and integration tests.
 * Corresponds to 2023-11-14T22:13:20.000Z — arbitrary but consistent.
 */
export const TEST_TIMESTAMP = 1_700_000_000_000;

```

**Tasks:**

1. **Test Code Quality Assessment:**
   - Review test file structure and organization
   - Assess test naming conventions (describe behavior, not implementation)
   - Evaluate test readability and maintainability
   - Check for code duplication in tests (DRY violations)
   - Validate proper use of test framework features
   - Assess assertion quality (specific, meaningful messages)

2. **Test Implementation Best Practices:**
   - Verify AAA pattern (Arrange-Act-Assert) usage
   - Check test isolation and independence
   - Review setup/teardown patterns and fixture usage
   - Validate mock usage (appropriate, not excessive)
   - Assess async/await handling correctness
   - Check for proper error testing patterns

3. **Test Refactoring Opportunities:**
   - Identify verbose or complex test code
   - Suggest test helper function extractions
   - Recommend shared fixture improvements
   - Propose test data organization strategies
   - Identify opportunities for parameterized tests
   - Suggest removing redundant test cases

4. **Framework-Specific Improvements:**
   - Recommend better matchers/assertions for clarity
   - Suggest framework features not being utilized
   - Identify anti-patterns specific to test framework
   - Propose modern testing patterns adoption
   - Check compatibility with framework version

5. **CI/CD and Performance Considerations:**
   - Identify slow-running tests
   - Check for non-deterministic behavior
   - Assess CI environment compatibility
   - Recommend test parallelization opportunities
   - Suggest test execution optimization strategies


**Approach**: Analyze ONLY the test files explicitly listed above. Do not invent test files or
assume a project structure that is not reflected in the provided context.

Review each listed test file for code quality, best practices, and framework usage.
Provide specific line-level feedback where applicable.

**Output:**
- Test code quality assessment with specific file:line references
- Best practice violations with concrete examples
- Refactoring recommendations with before/after code snippets
- Framework-specific improvement suggestions
- Performance optimization opportunities

**Tactical Focus:**
- Review actual test code, not coverage strategy
- Provide code-level improvements, not portfolio analysis
- Focus on HOW tests are written, not WHAT to test
- Give concrete examples and refactoring patterns
- Prioritize maintainability and clarity

**Examples of Good Feedback:**
- "Test at line 45: Extract common setup into beforeEach() for DRY"
- "Use expect(result).toHaveLength(3) instead of expect(result.length).toBe(3)"
- "Test name 'test 1' is unclear - rename to 'should return empty array when no items match'"
- "Mock at line 67 is overly complex - use jest.fn() with mockReturnValue instead"

Please analyze the existing tests and provide a detailed test strategy report with specific, actionable recommendations for improving test coverage and quality.

```

## Response

```
**Test Code Quality Assessment & Tactical Recommendations**

---

### 1. **File Structure & Organization**

- **Co-location**: All tests are in `test/`, grouped by domain (`core/`, `utils/`, `integration/`, `benchmarks/`, `helpers/`). This is clear and maintainable.
- **No __tests__/**: Acceptable, but consider using `__tests__` for convention and easier IDE/test runner integration.
- **Helper File**: `test/helpers/fixtures.ts` centralizes shared constants—good practice.

---

### 2. **Test Naming & Readability**

- **Descriptive Names**: Most test names describe behavior, e.g., `"should create a GeoPosition with full data"` (`test/core/GeoPosition.test.ts:17`), `"should resolve after the specified milliseconds"` (`test/utils/async.test.ts:6`).
- **Improvement**: Some test names could be more explicit, e.g., `"should be a Promise"` (`test/utils/async.test.ts:32`)—consider `"delay() returns a Promise"`.

---

### 3. **DRY Violations & Helper Extraction**

- **Duplication**: The `makeInput` function in `test/index.test.ts:13` is similar to `mockPos` in `test/core/GeocodingState.test.ts:6`. Extract a single shared helper in `test/helpers/fixtures.ts` for all position creation.
- **Setup Patterns**: Repeated instantiation of `GeoPosition` and `GeocodingState`—extract into `beforeEach()` where possible for clarity and DRY.

**Example Refactor:**
```typescript
// test/helpers/fixtures.ts
export function makeGeoPositionInput(lat: number, lon: number, accuracy = 10, timestamp = TEST_TIMESTAMP): GeoPositionInput {
  return { coords: { latitude: lat, longitude: lon, accuracy }, timestamp };
}
```
Replace all custom `makeInput`/`mockPos` usages with this helper.

---

### 4. **AAA Pattern & Test Isolation**

- **AAA Usage**: Most tests follow Arrange-Act-Assert, e.g., `test/core/GeoPosition.test.ts:18-41`.
- **Isolation**: Good isolation; no shared mutable state. Use of `jest.mock` in `GeoPosition.test.ts:6` is correct.
- **Improvement**: For async tests (`test/utils/async.test.ts`), ensure timers are reset in `afterEach()` to avoid bleed between tests.

---

### 5. **Mock Usage**

- **Appropriate Mocking**: `jest.mock('../../src/utils/distance')` in `GeoPosition.test.ts:6` is correct and scoped.
- **Improvement**: Use `jest.clearAllMocks()` in `afterEach()` to ensure mocks do not leak state.

---

### 6. **Async/Await Handling**

- **Correct Usage**: Async tests in `test/utils/async.test.ts` use `async/await` properly.
- **Improvement**: For timer-based tests, always restore real timers in `afterEach()` (see line 22). Consider using `beforeEach()`/`afterEach()` for timer setup/teardown.

---

### 7. **Error Testing Patterns**

- **Good Practice**: Use of `.toThrow()` and `.toThrowError()` is correct (`test/core/GeoPosition.edge-cases.test.ts:15-30`).
- **Improvement**: For error property assertions, use `.toThrow(expect.objectContaining({ name: 'GeoPositionError' }))` for clarity.

---

### 8. **Parameterized Tests**

- **Usage**: `it.each` is used in `test/core/GeoPosition.edge-cases.test.ts:17` and `test/index.test.ts:32`.
- **Improvement**: Expand parameterized tests for more edge cases, e.g., invalid coordinate combinations.

---

### 9. **Framework-Specific Improvements**

- **Matchers**: Use more expressive matchers:
  - Replace `expect(result.length).toBe(3)` with `expect(result).toHaveLength(3)`.
  - Use `.toBeNull()`/`.toBeUndefined()` instead of `.toEqual(null)`/`.toEqual(undefined)`.
- **Modern Patterns**: Use `test.each` instead of `it.each` for consistency.
- **Setup/Teardown**: Use `beforeAll`/`afterAll` for expensive setup (e.g., benchmarks).

---

### 10. **Performance & CI/CD**

- **Benchmarks**: `test/benchmarks/performance.benchmark.ts` uses generous thresholds and increases Jest timeout—good for CI.
- **Improvement**: Mark benchmarks with `.skip` or move to a separate suite to avoid slowing down regular test runs.
- **Non-determinism**: Timer-based tests (`test/utils/async.test.ts`) allow ±5ms/20ms—acceptable, but document rationale for CI stability.

---

### 11. **Redundant/Verbose Tests**

- **Redundancy**: Some error tests in `test/core/errors.test.ts` are repetitive (lines 6-35). Consolidate into parameterized tests.
- **Verbosity**: Long input objects in `GeoPosition.test.ts:18-41`—extract to shared fixtures for readability.

---

### 12. **Test Data Organization**

- **Shared Fixtures**: Centralize all test data creation in `test/helpers/fixtures.ts`.
- **Improvement**: Move all magic numbers (e.g., coordinates, timestamps) to named constants.

---

### 13. **Line-Level Feedback & Refactoring Examples**

- **test/core/GeoPosition.test.ts:18-41**: Extract repeated input objects to fixtures.
- **test/core/GeocodingState.test.ts:6, test/index.test.ts:13**: Use a single helper for position input.
- **test/utils/async.test.ts:22**: Move timer setup/teardown to `beforeEach`/`afterEach`.
- **test/core/errors.test.ts:6-35**: Use `it.each` for error property assertions.

**Before:**
```typescript
it('should set the correct name', () => {
  const err = new GeoPositionError('Test error');
  expect(err.name).toBe('GeoPositionError');
});
```
**After:**
```typescript
it.each([
  ['Test error', 'GeoPositionError'],
  ['Another error', 'GeoPositionError'],
])('should set name for %s', (msg, expectedName) => {
  const err = new GeoPositionError(msg);
  expect(err.name).toBe(expectedName);
});
```

---

### 14. **Summary of Tactical Recommendations**

- Extract all position input helpers to `test/helpers/fixtures.ts` for DRY.
- Use `beforeEach`/`afterEach` for setup/teardown, especially for timers and mocks.
- Replace verbose assertions with expressive matchers (`toHaveLength`, `toBeNull`, etc.).
- Consolidate repetitive error tests into parameterized tests.
- Move benchmarks to a separate suite or mark as `.skip` for regular CI runs.
- Document rationale for timing tolerances in async tests.
- Use modern Jest patterns (`test.each`, `beforeAll`, etc.) for clarity and maintainability.
- Centralize all magic values and test data in shared fixtures.

---

**Implementing these recommendations will improve maintainability, readability, and reliability of your test suite, reduce duplication, and ensure best practices are followed.**
```