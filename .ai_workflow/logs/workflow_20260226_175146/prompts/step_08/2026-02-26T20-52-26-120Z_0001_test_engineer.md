# Prompt Log

**Timestamp:** 2026-02-26T20:52:26.120Z
**Persona:** test_engineer
**Model:** gpt-4.1

## Prompt

```
**Role**: You are a senior CI/CD engineer and test results analyst with expertise in test execution diagnostics, failure root cause analysis, code coverage interpretation, performance optimization, and continuous integration best practices.

**Task**: Analyze test execution results, diagnose failures, and provide actionable recommendations for improving test suite quality and CI/CD integration.

**Context:**
- Project:  ()
- Primary Language: 
- Test Config:  via ``
- Exit Code: 
- Results: 0/ passed, 0 failed

**Test Execution Results:**


**Output:**


**Failed Tests:**


**Tasks:**

1. **Test Failure Root Cause Analysis:**
   - Identify why tests failed (assertion errors, runtime errors, timeouts)
   - Determine if failures are code bugs or test issues
   - Categorize failures (breaking changes, environment issues, flaky tests)
   - Provide specific fix recommendations for each failure
   - Priority level (Critical/High/Medium/Low) for each failure

2. **Coverage Gap Interpretation:**
   - Analyze coverage metrics (statements, branches, functions, lines)
   - Identify which modules have low coverage
   - Determine if coverage meets 80% target
   - Recommend areas for additional test coverage
   - Prioritize coverage improvements

3. **Performance Bottleneck Detection:**
   - Identify slow-running tests (if timing data available)
   - Detect tests with heavy setup/teardown
   - Find tests that could be parallelized
   - Recommend test execution optimizations
   - Suggest mocking strategies for faster tests

4. **Flaky Test Analysis** (if multiple runs available):
   - Review test output for timing-related errors (timeouts, race conditions)
   - Identify tests that interact with external systems (filesystem, network, subprocesses)
   - Flag tests with random data generation without seeding
   - Note: True flaky test detection requires multiple runs; provide best-effort analysis from single execution
   - Recommend fixes for identified potential flaky patterns

5. **CI/CD Optimization Recommendations:**
   - Suggest test splitting strategies for CI
   - Recommend caching strategies
   - Propose pre-commit hook configurations
   - Suggest coverage thresholds for CI gates
   - Recommend test parallelization approaches


**Approach**: **Output:**
- Root cause analysis for each failure with file:line:test references
- Specific code fixes or test modifications needed
- Coverage improvement action plan
- Performance optimization recommendations
- Flaky test remediation steps
- CI/CD integration best practices
- Priority-ordered action items
- Estimated effort for each fix

Please provide a comprehensive test results analysis with specific, actionable recommendations.

```

## Response

```
No test execution data was provided—there are 0 tests run, 0 passed, and 0 failed, with no output, coverage, or timing information available.  
**Analysis and Recommendations:**

---

### 1. Test Failure Root Cause Analysis
- **Status:** No test failures detected (0 tests run).
- **Action:** Ensure tests are defined and test runner is correctly configured. Check for missing or misconfigured test files, or issues with test discovery.

### 2. Coverage Gap Interpretation
- **Status:** No coverage data available.
- **Action:** Enable coverage reporting in your test configuration (e.g., Jest: `--coverage`). Review that tests exist and are being executed.

### 3. Performance Bottleneck Detection
- **Status:** No timing or performance data available.
- **Action:** Once tests are running, enable timing output to identify slow tests.

### 4. Flaky Test Analysis
- **Status:** No test runs to analyze for flakiness.
- **Action:** After enabling and running tests, review for intermittent failures.

### 5. CI/CD Optimization Recommendations
- **Test Splitting:** Not applicable until tests are running.
- **Caching:** Enable dependency and coverage caching in CI once tests are present.
- **Pre-commit Hooks:** Add hooks to prevent commits without passing tests.
- **Coverage Gates:** Set a minimum threshold (e.g., 80%) once coverage is reported.
- **Parallelization:** Use CI parallelism features after test suite is operational.

---

**Priority-Ordered Action Items:**
1. **Critical:** Verify test files exist and are discoverable by your test runner.
2. **Critical:** Check test configuration (e.g., jest.config.json) for correct testMatch/glob patterns.
3. **High:** Add or restore tests if missing.
4. **High:** Enable and review coverage reporting.
5. **Medium:** Integrate test and coverage checks into CI/CD.
6. **Medium:** Add pre-commit hooks for test enforcement.
7. **Low:** Optimize and parallelize tests after initial suite is running.

**Estimated Effort:**  
- Test discovery/configuration: 0.5–2 hours  
- Adding/restoring tests: varies (depends on codebase size)  
- CI/CD integration: 1–2 hours

---

**Next Steps:**  
- Confirm test files and configuration.
- Run tests with coverage enabled.
- Re-run analysis with actual test and coverage output for detailed recommendations.
```