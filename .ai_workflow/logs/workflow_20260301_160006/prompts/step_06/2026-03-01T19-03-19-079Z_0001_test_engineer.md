# Prompt Log

**Timestamp:** 2026-03-01T19:03:19.079Z
**Persona:** test_engineer
**Model:** gpt-4.1

## Prompt

```
**Role**: You are a hands-on test engineer and code quality specialist focused on reviewing existing test implementations, writing new test cases, assessing test code quality, and ensuring testing best practices are followed. You work with actual test code, not just strategy.

**Task**: Review existing test implementations and provide tactical recommendations for improving test code quality.

**Context:**
- Project: paraty_geocore.js (paraty_geocore.js)
- Primary Language: typescript
- Test Config: jest in npm test
- Commands: test=`npm test`, coverage=`npm run coverage`
- Total Test Files: 10
- Tests in __tests__/: 0
- Co-located Tests: 10

**Existing Test Files:**
test/index.test.ts, test/utils/async.test.ts, test/utils/distance.test.ts, test/integration/browser-geolocation.test.ts, test/core/GeoPosition.edge-cases.test.ts, test/core/GeoPosition.test.ts, test/core/GeocodingState.test.ts, test/core/ObserverSubject.test.ts, test/core/errors.test.ts, test/helpers/fixtures.ts

**Test File Contents:**
### test/index.test.ts
```typescript
/**
 * Smoke / contract tests for the public re-export surface of src/index.ts.
 *
 * These tests confirm that every symbol advertised by the package entry-point
 * is exported, has the correct shape, and behaves as documented.
 */
import {
  GeoPosition,
  GeoPositionError,
  GeocodingState,
  ObserverSubject,
  calculateDistance,
  EARTH_RADIUS_METERS,
  delay,
} from '../src/index';
import type { GeoCoords, GeoPositionInput, AccuracyQuality } from '../src/index';
import { TEST_TIMESTAMP, makeGeoPositionInput } from './helpers/fixtures';

// ---------------------------------------------------------------------------
// GeoPosition
// ---------------------------------------------------------------------------

describe('GeoPosition (exported from index)', () => {
  it('is the default export and is a constructor', () => {
    expect(typeof GeoPosition).toBe('function');
  });

  it('creates an instance from a valid GeoPositionInput', () => {
    const pos = new GeoPosition(makeGeoPositionInput(40.7128, -74.006, 5));
    expect(pos.latitude).toBe(40.7128);
    expect(pos.longitude).toBe(-74.006);
    expect(pos.accuracy).toBe(5);
    expect(pos.timestamp).toBe(TEST_TIMESTAMP);
  });

  it('instance is frozen (immutable)', () => {
    const pos = new GeoPosition(makeGeoPositionInput(0, 0));
    expect(Object.isFrozen(pos)).toBe(true);
  });

  it('throws GeoPositionError when given a primitive', () => {
    expect(() => new GeoPosition(42 as any)).toThrow(GeoPositionError);
    expect(() => new GeoPosition('string' as any)).toThrow(GeoPositionError);
    expect(() => new GeoPosition(true as any)).toThrow(GeoPositionError);
  });

  it.each<[number, number]>([
    [-90, -180],
    [90, 180],
    [0, 0],
  ])('does NOT throw for extreme-but-valid coordinates: %p, %p', (lat, lon) => {
    expect(() => new GeoPosition(makeGeoPositionInput(lat, lon))).not.toThrow();
  });

  it('returns no-position string from toString() when coords are absent', () => {
    const pos = new GeoPosition({} as GeoPositionInput);
    expect(pos.toString()).toMatch(/No position data/);
  });

  describe('GeoPosition.from() factory', () => {
    it('returns a GeoPosition equal to new GeoPosition()', () => {
      const input = makeGeoPositionInput(-23.5505, -46.6333, 12);
      const a = new GeoPosition(input);
      const b = GeoPosition.from(input);
      expect(b.latitude).toBe(a.latitude);
      expect(b.longitude).toBe(a.longitude);
    });
  });

  describe('GeoPosition.getAccuracyQuality() static method', () => {
    it.each<[number, AccuracyQuality]>([
      [5,       'excellent'],
      [10,      'excellent'],
      [11,      'good'],
      [30,      'good'],
      [31,      'medium'],
      [100,     'medium'],
      [101,     'bad'],
      [200,     'bad'],
      [201,
... (truncated)
```

### test/utils/async.test.ts
```typescript
// test/utils/async.test.ts
import { delay } from '../../src/utils/async';

describe('utils/async delay', () => {
  it('should resolve after the specified milliseconds', async () => {
    const start = Date.now();
    await delay(50);
    expect(Date.now() - start).toBeGreaterThanOrEqual(45); // allow ±5ms for timer imprecision
  });

  it('should resolve immediately for 0 ms', async () => {
    const start = Date.now();
    await delay(0);
    expect(Date.now() - start).toBeLessThan(20); // event-loop tick; allow up to 20ms
  });

  it('should resolve immediately for negative ms (clamped to 0)', async () => {
    // Negative values are clamped to 0; resolves on the next event-loop tick.
    const start = Date.now();
    await delay(-10);
    expect(Date.now() - start).toBeLessThan(20);
  });

  it('should work with large ms values', async () => {
    jest.useFakeTimers();
    try {
      const promise = delay(1000);
      jest.advanceTimersByTime(1000);
      await expect(promise).resolves.toBeUndefined();
    } finally {
      jest.useRealTimers();
    }
  });

  it('delay() returns a Promise', () => {
    const result = delay(10);
    expect(result).toBeInstanceOf(Promise);
  });
});

```

### test/utils/distance.test.ts
```typescript
/**
 * Unit tests for utils/distance
 *
 * Covers: EARTH_RADIUS_METERS, calculateDistance
 * FRS: AC-DI-01 through AC-DI-04
 */
import { calculateDistance, EARTH_RADIUS_METERS } from '../../src/utils/distance';

// ---------------------------------------------------------------------------
// Known reference points
// ---------------------------------------------------------------------------
const SAO_PAULO = { lat: -23.5505, lon: -46.6333 };
const RIO_DE_JANEIRO = { lat: -22.9068, lon: -43.1729 };

// Haversine result for the exact coordinates above (matches integration test fixture)
const SP_RIO_METERS = 360_748;

describe('EARTH_RADIUS_METERS', () => {
  it('equals 6,371,000 m (mean Earth radius)', () => {
    // AC-DI-04
    expect(EARTH_RADIUS_METERS).toBe(6_371_000);
  });

  it('is a positive finite number', () => {
    expect(EARTH_RADIUS_METERS).toBeGreaterThan(0);
    expect(Number.isFinite(EARTH_RADIUS_METERS)).toBe(true);
  });
});

describe('calculateDistance', () => {
  describe('AC-DI-02 — same-point distance is zero', () => {
    it('returns 0 for identical coordinates', () => {
      expect(calculateDistance(0, 0, 0, 0)).toBe(0);
    });

    it('returns 0 for identical non-zero coordinates', () => {
      expect(calculateDistance(SAO_PAULO.lat, SAO_PAULO.lon, SAO_PAULO.lat, SAO_PAULO.lon)).toBe(0);
    });
  });

  describe('AC-DI-01 — correct distance for known points', () => {
    it('São Paulo → Rio de Janeiro is within 1% of Haversine reference', () => {
      const d = calculateDistance(SAO_PAULO.lat, SAO_PAULO.lon, RIO_DE_JANEIRO.lat, RIO_DE_JANEIRO.lon);
      expect(d).toBeCloseTo(SP_RIO_METERS, -3); // within 1,000 m
      expect(Math.abs(d - SP_RIO_METERS) / SP_RIO_METERS).toBeLessThan(0.01);
    });

    it('1° latitude apart ≈ 111,195 m at the equator', () => {
      const d = calculateDistance(0, 0, 1, 0);
      expect(d).toBeCloseTo(111_195, -2); // within 100 m
    });

    it('1° longitude apart ≈ 111,195 m at the equator', () => {
      const d = calculateDistance(0, 0, 0, 1);
      expect(d).toBeCloseTo(111_195, -2);
    });
  });

  describe('AC-DI-03 — pure function behaviour', () => {
    it('returns the same value on repeated calls with the same input', () => {
      const args: [number, number, number, number] = [SAO_PAULO.lat, SAO_PAULO.lon, RIO_DE_JANEIRO.lat, RIO_DE_JANEIRO.lon];
      const r1 = calculateDistance(...args);
      const r2 = calculateDistance(...args);
      const r3 = calculateDistance(...args);
      expect(r1).toBe(r2);
      expect(r2).toBe(r3);
    });

    it('does not modify its arguments', () => {
      const lat1 = -23.5505, lon1 = -46.6333, lat2 = -22.9068, lon2 = -43.1729;
      calculateDistance(lat1, lon1, lat2, lon2);
      expect(lat1).toBe(-23.5505);
      expect(lon1).toBe(
... (truncated)
```

### test/integration/browser-geolocation.test.ts
```typescript
/**
 * Integration tests — browser Geolocation API simulation
 *
 * These tests verify the full pipeline using GeolocationPosition objects
 * that simulate the browser implementation: coords are exposed via
 * non-enumerable getters (spread / Object.assign produce an empty object),
 * which is the exact behaviour that GeoPosition.parseCoords must handle.
 */

import GeoPosition from '../../src/core/GeoPosition';
import { calculateDistance } from '../../src/utils/distance';
import { TEST_TIMESTAMP } from '../helpers/fixtures';

// ---------------------------------------------------------------------------
// Browser GeolocationPosition factory
// ---------------------------------------------------------------------------

interface FakeCoords {
  latitude: number;
  longitude: number;
  accuracy: number;
  altitude?: number | null;
  altitudeAccuracy?: number | null;
  heading?: number | null;
  speed?: number | null;
}

/**
 * Creates a GeolocationPosition-like object whose coords properties are
 * exposed as non-enumerable getters — identical to Chrome / Firefox behaviour.
 */
function makeBrowserPosition(coords: FakeCoords, timestamp = TEST_TIMESTAMP): object {
  const coordsObj = Object.create(null);
  for (const [key, value] of Object.entries(coords) as [keyof FakeCoords, unknown][]) {
    Object.defineProperty(coordsObj, key, {
      get: () => value ?? null,
      enumerable: false,  // non-enumerable: spread/assign yields {}
      configurable: false,
    });
  }

  const positionObj = Object.create(null);
  Object.defineProperty(positionObj, 'coords', { get: () => coordsObj, enumerable: true });
  Object.defineProperty(positionObj, 'timestamp', { get: () => timestamp, enumerable: true });
  return positionObj;
}

// ---------------------------------------------------------------------------
// Shared fixture
// ---------------------------------------------------------------------------

const SAO_PAULO = { latitude: -23.5505, longitude: -46.6333, accuracy: 12 };
const RIO_DE_JANEIRO = { latitude: -22.9068, longitude: -43.1729, accuracy: 18 };
const EXPECTED_SP_RIO_METERS = 360_748; // Haversine result for the given coordinates, ±1%

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

describe('Integration: browser GeolocationPosition → GeoPosition', () => {
  describe('non-enumerable coords extraction', () => {
    it('reads latitude and longitude from non-enumerable getters', () => {
      const raw = makeBrowserPosition(SAO_PAULO, TEST_TIMESTAMP);
      const pos = new GeoPosition(raw as any);

      expect(pos.latitude).toBe(SAO_PAULO.latitude);
      expect(pos.longitude).toBe(SAO_PAULO.longitude);
      expect(pos.accuracy)
... (truncated)
```

### test/core/GeoPosition.edge-cases.test.ts
```typescript
/**
 * Edge-case tests for GeoPosition.
 *
 * Covers unusual, boundary, and malformed inputs not exercised by the main unit tests.
 */

import GeoPosition from '../../src/core/GeoPosition';
import { GeoPositionError } from '../../src/core/errors';

describe('GeoPosition — edge cases', () => {

  // -------------------------------------------------------------------------
  // Input validation / error handling
  // -------------------------------------------------------------------------

  describe('constructor — invalid primitive input', () => {
    it.each([42, 'string', true, Symbol('s')])(
      'throws GeoPositionError for primitive: %p',
      (primitive) => {
        expect(() => new GeoPosition(primitive as any)).toThrow(GeoPositionError);
        expect(() => new GeoPosition(primitive as any)).toThrow(/must be an object/);
      },
    );

    it('thrown error is also an instance of Error', () => {
      expect(() => new GeoPosition(99 as any)).toThrow(Error);
    });

    it('thrown error has name "GeoPositionError"', () => {
      expect(() => new GeoPosition('bad' as any)).toThrow(
        expect.objectContaining({ name: 'GeoPositionError' }),
      );
    });

    it('accepts null-ish objects gracefully (no throw)', () => {
      expect(() => new GeoPosition({})).not.toThrow();
      expect(() => new GeoPosition({ coords: undefined })).not.toThrow();
    });
  });

  // -------------------------------------------------------------------------
  // Extreme coordinate values
  // -------------------------------------------------------------------------

  describe('extreme coordinate values', () => {
    it('handles latitude = +90 (North Pole)', () => {
      const pos = new GeoPosition({ coords: { latitude: 90, longitude: 0, accuracy: 5 } });
      expect(pos.latitude).toBe(90);
      expect(pos.accuracyQuality).toBe('excellent');
    });

    it('handles latitude = -90 (South Pole)', () => {
      const pos = new GeoPosition({ coords: { latitude: -90, longitude: 0, accuracy: 5 } });
      expect(pos.latitude).toBe(-90);
    });

    it('handles longitude = +180 (antimeridian east)', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: 180, accuracy: 10 } });
      expect(pos.longitude).toBe(180);
    });

    it('handles longitude = -180 (antimeridian west)', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: -180, accuracy: 10 } });
      expect(pos.longitude).toBe(-180);
    });

    it('handles very large positive accuracy', () => {
      const pos = new GeoPosition({ coords: { latitude: 0, longitude: 0, accuracy: 1_000_000 } });
      expect(pos.accuracyQuality).toBe('very bad');
    });

    it('handles accuracy = 0', () => {
      const pos = new GeoPosition({ coords: { latitude: 
... (truncated)
```

### test/core/GeoPosition.test.ts
```typescript
// src/core/GeoPosition.test.ts

import GeoPosition, { GeoCoords, GeoPositionInput, AccuracyQuality } from '../../src/core/GeoPosition';
import { calculateDistance } from '../../src/utils/distance';

jest.mock('../../src/utils/distance', () => ({
	calculateDistance: jest.fn(),
}));

describe('GeoPosition', () => {
	const mockDistance = 1234.56;
	beforeEach(() => {
		(calculateDistance as jest.Mock).mockReturnValue(mockDistance);
	});
	afterEach(() => {
		jest.clearAllMocks();
	});

	describe('constructor', () => {
		it('should create a GeoPosition with full data', () => {
			const input: GeoPositionInput = {
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			};
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBe(-23.5505);
			expect(pos.longitude).toBe(-46.6333);
			expect(pos.accuracy).toBe(15);
			expect(pos.altitude).toBe(760);
			expect(pos.altitudeAccuracy).toBe(5);
			expect(pos.heading).toBe(0);
			expect(pos.speed).toBe(0);
			expect(pos.timestamp).toBe(1634567890123);
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1634567890123,
				coords: {
					latitude: -23.5505,
					longitude: -46.6333,
					accuracy: 15,
					altitude: 760,
					altitudeAccuracy: 5,
					heading: 0,
					speed: 0,
				},
			});
			expect(Object.isFrozen(pos)).toBe(true);
			expect(Object.isFrozen(pos.geolocationPosition!)).toBe(true);
			expect(Object.isFrozen(pos.coords!)).toBe(true);
		});

		it('should handle missing coords gracefully', () => {
			const input: GeoPositionInput = { timestamp: 1234567890 };
			const pos = new GeoPosition(input);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: 1234567890,
				coords: {},
			});
		});

		it('should handle null/undefined input', () => {
			const pos = new GeoPosition({} as GeoPositionInput);
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracy).toBeUndefined();
			expect(pos.coords).toBeNull();
			expect(pos.geolocationPosition).toEqual({
				timestamp: undefined,
				coords: {},
			});
		});

		it('should set geolocationPosition to null when position is null', () => {
			const pos = new GeoPosition(null as any);
			expect(pos.geolocationPosition).toBeNull();
			expect(pos.coords).toBeNull();
			expect(pos.latitude).toBeUndefined();
			expect(pos.longitude).toBeUndefined();
			expect(pos.accuracyQuality).toBe('very bad');
		});

		it('should handle partial coords', () => {
			const input: GeoPositionInput = {
				coords: { l
... (truncated)
```

### test/core/GeocodingState.test.ts
```typescript
// test/core/GeocodingState.test.ts

import GeocodingState from '../../src/core/GeocodingState';
import ObserverSubject from '../../src/core/ObserverSubject';
import GeoPosition from '../../src/core/GeoPosition';
import { makeGeoPositionInput } from '../helpers/fixtures';


describe('GeocodingState', () => {
describe('constructor', () => {
it('should create instance with null initial state', () => {
const state = new GeocodingState();
expect(state).toBeInstanceOf(GeocodingState);
expect(state).toBeInstanceOf(ObserverSubject);
expect(state.getCurrentPosition()).toBeNull();
expect(state.getCurrentCoordinates()).toBeNull();
});

it('should initialize with zero observers', () => {
const state = new GeocodingState();
expect(state.getObserverCount()).toBe(0);
});
});

describe('setPosition()', () => {
it('should update position with a valid GeoPosition', () => {
const state = new GeocodingState();
const pos = new GeoPosition(makeGeoPositionInput(-23.5505, -46.6333));
state.setPosition(pos);
expect(state.getCurrentPosition()).toBe(pos);
});

it('should update coordinates when position is set', () => {
const state = new GeocodingState();
state.setPosition(new GeoPosition(makeGeoPositionInput(-23.5505, -46.6333)));
expect(state.getCurrentCoordinates()).toEqual({ latitude: -23.5505, longitude: -46.6333 });
});

it('should accept null to clear position', () => {
const state = new GeocodingState();
state.setPosition(new GeoPosition(makeGeoPositionInput(-23.5505, -46.6333)));
state.setPosition(null);
expect(state.getCurrentPosition()).toBeNull();
expect(state.getCurrentCoordinates()).toBeNull();
});

it('should throw TypeError for non-GeoPosition values', () => {
const state = new GeocodingState();
expect(() => state.setPosition({ latitude: 10, longitude: 20 } as any)).toThrow(TypeError);
expect(() => state.setPosition('invalid' as any)).toThrow(TypeError);
expect(() => state.setPosition(123 as any)).toThrow(TypeError);
});

it('should notify observers when position changes', () => {
const state = new GeocodingState();
const observer = jest.fn();
const pos = new GeoPosition(makeGeoPositionInput(-23.5505, -46.6333));
state.subscribe(observer);
state.setPosition(pos);
expect(observer).toHaveBeenCalledTimes(1);
expect(observer).toHaveBeenCalledWith({
position: pos,
coordinates: { latitude: -23.5505, longitude: -46.6333 },
});
});

it('should not notify observers when set to null', () => {
const state = new GeocodingState();
const observer = jest.fn();
state.subscribe(observer);
state.setPosition(null);
expect(observer).not.toHaveBeenCalled();
});

it('should handle observer errors gracefully', () => {
const state = new GeocodingState();
const errorObserver = jest.fn(() => { throw new Error('boom'); });
const successObserver = jest.fn();
const warnSpy = jest.spyOn(co
... (truncated)
```

### test/core/ObserverSubject.test.ts
```typescript
// test/core/ObserverSubject.test.ts

import ObserverSubject from '../../src/core/ObserverSubject';

describe('ObserverSubject', () => {
    describe('constructor', () => {
        it('should create instance with zero observers', () => {
            const subject = new ObserverSubject();
            expect(subject).toBeInstanceOf(ObserverSubject);
            expect(subject.getObserverCount()).toBe(0);
        });

        it('should be directly instantiable (concrete class)', () => {
            expect(() => new ObserverSubject()).not.toThrow();
        });
    });

    describe('subscribe()', () => {
        it('should register a callback and return an unsubscribe function', () => {
            const subject = new ObserverSubject<{ value: number }>();
            const unsubscribe = subject.subscribe(jest.fn());
            expect(typeof unsubscribe).toBe('function');
            expect(subject.getObserverCount()).toBe(1);
        });

        it('should throw TypeError for non-function callback', () => {
            const subject = new ObserverSubject();
            expect(() => subject.subscribe(null as any)).toThrow(TypeError);
            expect(() => subject.subscribe('str' as any)).toThrow(TypeError);
            expect(() => subject.subscribe(42 as any)).toThrow(TypeError);
        });

        it('should support multiple subscribers', () => {
            const subject = new ObserverSubject();
            subject.subscribe(jest.fn());
            subject.subscribe(jest.fn());
            subject.subscribe(jest.fn());
            expect(subject.getObserverCount()).toBe(3);
        });

        it('returned unsubscribe removes only that callback', () => {
            const subject = new ObserverSubject<string>();
            const obs1 = jest.fn();
            const obs2 = jest.fn();
            subject.subscribe(obs1);
            const unsub2 = subject.subscribe(obs2);
            unsub2();
            subject._notifyObservers('ping');
            expect(obs1).toHaveBeenCalledWith('ping');
            expect(obs2).not.toHaveBeenCalled();
        });

        it('double unsubscribe does not throw', () => {
            const subject = new ObserverSubject();
            const unsub = subject.subscribe(jest.fn());
            unsub();
            expect(() => unsub()).not.toThrow();
        });
    });

    describe('unsubscribe()', () => {
        it('should return true when callback is found and removed', () => {
            const subject = new ObserverSubject();
            const cb = jest.fn();
            subject.subscribe(cb);
            expect(subject.unsubscribe(cb)).toBe(true);
            expect(subject.getObserverCount()).toBe(0);
        });

        it('should return false when callback is not registered', () => {
            const
... (truncated)
```

### test/core/errors.test.ts
```typescript
// test/core/errors.test.ts
import { GeoPositionError } from '../../src/core/errors';

describe('GeoPositionError', () => {
  it('should be instance of Error', () => {
    const err = new GeoPositionError('Invalid position');
    expect(err).toBeInstanceOf(Error);
    expect(err).toBeInstanceOf(GeoPositionError);
  });

  it('should set the correct name', () => {
    const err = new GeoPositionError('Test error');
    expect(err.name).toBe('GeoPositionError');
  });

  it('should set the correct message', () => {
    const err = new GeoPositionError('GeoPosition: position must be an object');
    expect(err.message).toBe('GeoPosition: position must be an object');
  });

  it('should maintain prototype chain', () => {
    const err = new GeoPositionError('Chain test');
    expect(Object.getPrototypeOf(err)).toBe(GeoPositionError.prototype);
  });

  it('should be catchable as GeoPositionError', () => {
    const err = new GeoPositionError('Catch test');
    expect(err).toBeInstanceOf(GeoPositionError);
    expect(err.message).toBe('Catch test');
  });

  it('should allow custom properties', () => {
    const err = new GeoPositionError('Custom');
    (err as any).code = 123;
    expect((err as any).code).toBe(123);
  });
});

```

### test/helpers/fixtures.ts
```typescript
/**
 * Shared test fixtures and constants for paraty_geocore.js test suites.
 *
 * Import these instead of repeating magic values across test files.
 */

import type { GeoPositionInput } from '../../src/core/GeoPosition';

/**
 * A stable, well-known Unix timestamp used across unit and integration tests.
 * Corresponds to 2023-11-14T22:13:20.000Z — arbitrary but consistent.
 */
export const TEST_TIMESTAMP = 1_700_000_000_000;

/**
 * Creates a minimal {@link GeoPositionInput} for use in unit tests.
 *
 * All optional coord fields default to `null`; `timestamp` is always
 * {@link TEST_TIMESTAMP} to prevent non-deterministic `Date.now()` values
 * from leaking into test output.
 *
 * @param lat - Latitude in decimal degrees
 * @param lon - Longitude in decimal degrees
 * @param accuracy - GPS accuracy in metres (default: 10)
 */
export function makeGeoPositionInput(lat: number, lon: number, accuracy = 10): GeoPositionInput {
  return {
    coords: {
      latitude: lat,
      longitude: lon,
      accuracy,
      altitude: null,
      altitudeAccuracy: null,
      heading: null,
      speed: null,
    },
    timestamp: TEST_TIMESTAMP,
  };
}

```

**Tasks:**

1. **Test Code Quality Assessment:**
   - Review test file structure and organization
   - Assess test naming conventions (describe behavior, not implementation)
   - Evaluate test readability and maintainability
   - Check for code duplication in tests (DRY violations)
   - Validate proper use of test framework features
   - Assess assertion quality (specific, meaningful messages)

2. **Test Implementation Best Practices:**
   - Verify AAA pattern (Arrange-Act-Assert) usage
   - Check test isolation and independence
   - Review setup/teardown patterns and fixture usage
   - Validate mock usage (appropriate, not excessive)
   - Assess async/await handling correctness
   - Check for proper error testing patterns

3. **Test Refactoring Opportunities:**
   - Identify verbose or complex test code
   - Suggest test helper function extractions
   - Recommend shared fixture improvements
   - Propose test data organization strategies
   - Identify opportunities for parameterized tests
   - Suggest removing redundant test cases

4. **Framework-Specific Improvements:**
   - Recommend better matchers/assertions for clarity
   - Suggest framework features not being utilized
   - Identify anti-patterns specific to test framework
   - Propose modern testing patterns adoption
   - Check compatibility with framework version

5. **CI/CD and Performance Considerations:**
   - Identify slow-running tests
   - Check for non-deterministic behavior
   - Assess CI environment compatibility
   - Recommend test parallelization opportunities
   - Suggest test execution optimization strategies


**Approach**: Analyze ONLY the test files explicitly listed above. Do not invent test files or
assume a project structure that is not reflected in the provided context.

Review each listed test file for code quality, best practices, and framework usage.
Provide specific line-level feedback where applicable.

**Output:**
- Test code quality assessment with specific file:line references
- Best practice violations with concrete examples
- Refactoring recommendations with before/after code snippets
- Framework-specific improvement suggestions
- Performance optimization opportunities

**Tactical Focus:**
- Review actual test code, not coverage strategy
- Provide code-level improvements, not portfolio analysis
- Focus on HOW tests are written, not WHAT to test
- Give concrete examples and refactoring patterns
- Prioritize maintainability and clarity

**Examples of Good Feedback:**
- "Test at line 45: Extract common setup into beforeEach() for DRY"
- "Use expect(result).toHaveLength(3) instead of expect(result.length).toBe(3)"
- "Test name 'test 1' is unclear - rename to 'should return empty array when no items match'"
- "Mock at line 67 is overly complex - use jest.fn() with mockReturnValue instead"

Please analyze the existing tests and provide a detailed test strategy report with specific, actionable recommendations for improving test coverage and quality.

```

## Response

```
Test Code Quality Assessment & Tactical Recommendations  
---

### 1. **Test File Structure & Organization**

- **Strengths:**  
  - All test files are co-located in `test/` with clear subfolders (`core`, `utils`, `integration`, `helpers`).
  - Helper functions and constants are extracted to `test/helpers/fixtures.ts` (good DRY practice).

- **Improvements:**  
  - Consider moving all test files to a dedicated `__tests__/` directory for better convention alignment (optional, as co-location is acceptable).
  - Ensure all test files have consistent naming (`*.test.ts` is good).

---

### 2. **Test Naming Conventions**

- **Strengths:**  
  - Most test names describe behavior (e.g., "should resolve after the specified milliseconds", "returns 0 for identical coordinates").
  - Use of `describe` blocks to group related behaviors.

- **Improvements:**  
  - Some test names are verbose or implementation-focused (e.g., `constructor — invalid primitive input` in `GeoPosition.edge-cases.test.ts`).  
    **Recommendation:** Use behavior-driven names, e.g., "throws error for non-object input".
  - In `GeoPosition.test.ts`, test names like "should create a GeoPosition with full data" can be more descriptive: "creates immutable GeoPosition from complete input".

---

### 3. **Test Readability & Maintainability**

- **Strengths:**  
  - Consistent use of AAA pattern (Arrange-Act-Assert) in most tests.
  - Shared fixtures (`makeGeoPositionInput`, `TEST_TIMESTAMP`) reduce magic values.

- **Improvements:**  
  - **Line 45, `GeoPosition.test.ts`:**  
    Multiple tests repeat input object construction.  
    **Refactor:** Extract common input objects to a shared `beforeEach` or helper function.
  - **Edge-case tests:**  
    Consider grouping similar error cases with `it.each` for conciseness.

---

### 4. **Code Duplication (DRY Violations)**

- **Findings:**  
  - Repeated construction of `GeoPositionInput` objects across files.
  - Repeated use of `{ latitude: -23.5505, longitude: -46.6333 }` in multiple tests.

- **Recommendations:**  
  - Use shared fixtures for all common coordinates and test data.
  - Extract repeated error assertion patterns into helper functions, e.g.:
    ```typescript
    function expectGeoPositionError(input: any) {
      expect(() => new GeoPosition(input)).toThrow(GeoPositionError);
    }
    ```

---

### 5. **Test Framework Feature Usage**

- **Strengths:**  
  - Use of `it.each` for parameterized tests.
  - Use of `jest.mock` for mocking dependencies.

- **Improvements:**  
  - **`ObserverSubject.test.ts`, line 45:**  
    Direct calls to private methods (`_notifyObservers`) are discouraged.  
    **Refactor:** Test public API only.
  - Use more expressive matchers:  
    - Replace `expect(result.length).toBe(3)` with `expect(result).toHaveLength(3)`.
    - Use `toBeNull()`/`toBeUndefined()` for clarity.

---

### 6. **Assertion Quality**

- **Strengths:**  
  - Assertions are specific and meaningful (e.g., `expect(pos.latitude).toBe(90)`).

- **Improvements:**  
  - Add custom error messages for complex assertions to aid debugging.
  - Use `toStrictEqual` for deep object comparisons where shape matters.

---

### 7. **AAA Pattern, Isolation, Setup/Teardown**

- **Strengths:**  
  - Most tests follow AAA pattern.
  - Use of `beforeEach`/`afterEach` for mock setup/teardown.

- **Improvements:**  
  - **`GeoPosition.test.ts`, line 20:**  
    Some tests could benefit from more explicit Arrange/Act/Assert separation (add comments or whitespace).
  - Ensure all mocks are reset between tests to avoid leakage.

---

### 8. **Mock Usage**

- **Strengths:**  
  - Use of `jest.mock` for `calculateDistance`.

- **Improvements:**  
  - Avoid mocking internal implementation unless necessary for isolation.  
    **Refactor:** Prefer integration-style tests unless external dependencies require mocking.

---

### 9. **Async/Await Handling**

- **Strengths:**  
  - Proper use of `async`/`await` in `async.test.ts`.

- **Improvements:**  
  - **`async.test.ts`, line 20:**  
    Use `await expect(delay(50)).resolves.toBeUndefined()` for more idiomatic async assertion.

---

### 10. **Error Testing Patterns**

- **Strengths:**  
  - Use of `toThrow` and `toThrowError` for error assertions.

- **Improvements:**  
  - Use `toThrowErrorMatchingSnapshot()` for error message regression where appropriate.

---

### 11. **Refactoring Opportunities**

- **Verbose/Complex Test Code:**  
  - Extract repeated test data and error patterns into helpers.
  - Use parameterized tests for edge cases.

- **Test Helper Function Extraction:**  
  - Move all coordinate fixtures to `helpers/fixtures.ts`.
  - Create reusable error assertion helpers.

- **Test Data Organization:**  
  - Group all test constants in a single file for easy updates.

---

### 12. **Framework-Specific Improvements**

- **Better Matchers:**  
  - Use `toHaveLength`, `toBeNull`, `toBeUndefined`, `toStrictEqual` for clarity.

- **Modern Patterns:**  
  - Use `jest.spyOn` for method spies instead of manual mocks.
  - Use `test.each` for all parameterized cases.

- **Anti-Patterns:**  
  - Avoid testing private methods or implementation details.

---

### 13. **CI/CD & Performance**

- **Slow-Running Tests:**  
  - `async.test.ts` uses real timers for some tests; consider using fake timers for all time-based tests to speed up execution.

- **Non-Deterministic Behavior:**  
  - All tests use fixed timestamps and fixtures—good practice.

- **Parallelization:**  
  - All tests are independent and can run in parallel; ensure no global state is mutated.

- **Optimization:**  
  - Use `jest --runInBand` only if tests are flaky; otherwise, default parallel execution is preferred.

---

## **Summary Table of Tactical Recommendations**

| File                                 | Line(s) | Issue/Opportunity                          | Recommendation/Refactor Example                |
|---------------------------------------|---------|--------------------------------------------|------------------------------------------------|
| test/core/GeoPosition.test.ts         | 45+     | Repeated input object construction         | Extract to shared fixture/helper               |
| test/core/GeoPosition.edge-cases.test.ts | 20+  | Verbose error assertions                   | Use helper function for error assertions       |
| test/core/ObserverSubject.test.ts     | 45      | Testing private method `_notifyObservers`  | Test via public API only                       |
| test/utils/async.test.ts              | 20      | Async assertion style                      | Use `await expect(delay(50)).resolves.toBeUndefined()` |
| test/core/GeocodingState.test.ts      | 30+     | Repeated observer setup                    | Extract observer setup to helper/fixture       |
| All                                  | -       | Use of expressive matchers                 | Prefer `toHaveLength`, `toBeNull`, etc.        |
| All                                  | -       | Parameterized edge-case tests              | Use `it.each` for all similar cases            |
| All                                  | -       | Custom error messages in assertions        | Add messages for complex assertions            |
| All                                  | -       | Test data organization                     | Centralize fixtures/constants                  |
| All                                  | -       | Test isolation                             | Ensure mocks/fixtures reset between tests      |

---

## **Before/After Refactoring Example**

**Before:**
```typescript
it('should throw GeoPositionError for primitive: %p', () => {
  expect(() => new GeoPosition(42 as any)).toThrow(GeoPositionError);
  expect(() => new GeoPosition('string' as any)).toThrow(GeoPositionError);
});
```

**After:**
```typescript
it.each([42, 'string', true, Symbol('s')])(
  'throws GeoPositionError for primitive: %p',
  (primitive) => {
    expectGeoPositionError(primitive);
  }
);

// In helpers/fixtures.ts
export function expectGeoPositionError(input: any) {
  expect(() => new GeoPosition(input)).toThrow(GeoPositionError);
}
```

---

## **Performance Optimization Example**

**Before:**
```typescript
it('should resolve after the specified milliseconds', async () => {
  const start = Date.now();
  await delay(50);
  expect(Date.now() - start).toBeGreaterThanOrEqual(45);
});
```

**After:**
```typescript
it('should resolve after the specified milliseconds', async () => {
  jest.useFakeTimers();
  const promise = delay(50);
  jest.advanceTimersByTime(50);
  await expect(promise).resolves.toBeUndefined();
  jest.useRealTimers();
});
```

---

## **Conclusion**

The test suite is well-structured and covers key behaviors, but can be improved by:
- Extracting repeated fixtures and helpers
- Using more expressive matchers and parameterized tests
- Avoiding private API testing and excessive mocking
- Optimizing async tests with fake timers
- Centralizing test data for maintainability

Implementing these tactical changes will improve readability, maintainability, and CI performance.
```